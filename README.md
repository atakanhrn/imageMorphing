# imageMorphing

Explanation of the code:
	In the code, firstly, the input and target image needs to be inserted from file->open input image or file->open target image. After the images are open, corresponding points from images can be selected. For the sake of testing corresponding points are firstly hard-coded. One can also add new corresponding points by simply selecting pixels from images from the application window. The selected points can be removed by clicking remove selected points button. This way, hard-coded points are removed from the array and corresponding points can be selected by mouse click. After the points are selected, the images are ready to be triangulated. For drawing triangles, built-in getTriangleList is used. Points are inserted in subdiv in order. The built-in function returns a list of corner points of triangles. These corners are checked whether they are really in a position to be inside the image. Lines are drawn between points to visualize the triangles. Then corner points of triangles are put in an array named triangleCornerList which holds 3 corner points of a triangle as an element. While creating triangulation, points are visualized as little, blue circles. While calling drawDelaunay function, these corner points are used. Triangulated images are saved to the folder of the executable and original images are copied not to lose them and make changes on a copy. 
In the morph button click, morphing is done. First, the number of corresponding points checked if they are matching. Then, triangles are sent to morphTriangle function one by one. While calling this function, as getTriangleList function messes the order of the points and mess the order of triangles, corresponding points are taken from points array with the same index of corresponding point. This function fills the empty initialized result image.
In the morphTriangle function, first, affine transform matrices are found by linear algebra calculations. Then, inverse of this matrix is calculated for reverse transformation. After that, the bounding rectangle of the triangle is calculated. The pixels within this rectangle are filled with corresponding pixels of the first image. Lastly, these pixels are masked to only keep triangular areaâ€™s pixels. In the end of the function, global result image is updated by adding these pixels to itself. This way, the result image is filled triangle by triangle.
	NOTE:	Corresponding points must be selected from the images in order. 
